###############################################################################
# Logstash Pipeline: Oracle → Elasticsearch (Upsert) + DB cascade-like deletes
# - Incremental ingest by UPDATED_AT (tracking_column)
# - Versioning: external version using updated_at (epoch_millis)
# - Normal rows: index to ES (or update+upsert로 바꿔도 OK)
# - Deleted rows (ES_DELETE_FLAG='Y'):
#     1) Delete ES document (with version)
#     2) Delete DB children (BOOK_HASHTAGS, WISHLISTS, CARTS, ORDERED_ITEM)
#     3) Delete DB parent (BOOKS)
###############################################################################

input {
  jdbc {
    jdbc_connection_string => "jdbc:oracle:thin:@localhost:1521:xe"
    jdbc_user              => "GEULBUT"
    jdbc_password          => "1234567890"

    jdbc_driver_library    => "C:/Work/logstashconf/ojdbc11.jar"
    jdbc_driver_class      => "Java::oracle.jdbc.OracleDriver"

    schedule               => "* * * * *"

    use_column_value       => true
    tracking_column        => "updated_at"
    tracking_column_type   => "timestamp"
    record_last_run        => true
    last_run_metadata_path => "C:/Work/logstashconf/.last_run_books"

    statement => "
      SELECT
        b.BOOK_ID                AS id,
        b.TITLE                  AS title,
        b.PRICE                  AS price,
        b.DISCOUNTED_PRICE       AS discounted_price,
        b.STOCK                  AS stock,

        b.AUTHOR_NAME            AS author_name,
        b.CATEGORY_NAME          AS category_name,
        b.PUBLISHER_NAME         AS publisher_name,
        b.BOOK_IMG_URL           AS book_img_url,

        b.ISBN                   AS isbn,
        b.NATION                 AS nation,
        b.HASHTAGS               AS hashtags,

        b.PUB_DATE               AS pub_date,
        b.CREATED_AT             AS created_at,
        b.SALES_COUNT            AS sales_count,
        b.WISH_COUNT             AS wish_count,
        b.POPULARITY_SCORE       AS popularity_score,

        b.ES_DELETE_FLAG         AS es_delete_flag,
        CAST(b.UPDATED_AT AS TIMESTAMP) AS updated_at
      FROM ES_BOOKS_SEARCH_VW b
      WHERE :sql_last_value IS NULL OR b.UPDATED_AT > :sql_last_value
      ORDER BY b.UPDATED_AT ASC
    "

    jdbc_paging_enabled => true
    jdbc_page_size      => 500
  }
}

filter {
  mutate {
    convert => {
      "price"             => "integer"
      "discounted_price"  => "integer"
      "stock"             => "integer"
      "sales_count"       => "integer"
      "wish_count"        => "integer"
      "popularity_score"  => "float"
    }
    rename => { "id" => "book_id" }
  }

  # ES delete flag: normalize to 'N' / 'Y'
  ruby {
    code => "
      flag = event.get('es_delete_flag')
      flag = flag.nil? ? 'N' : flag.to_s.upcase
      event.set('es_delete_flag', flag)
    "
  }

  # hashtags: CSV/JSON → Array (always array)
  ruby {
    code => '
      v = event.get("hashtags")
      if v.nil? || v == ""
        event.set("hashtags", [])
      elsif v.is_a?(Array)
        arr = v.map{|x| x.to_s.strip}.reject{|x| x.empty?}.uniq
        event.set("hashtags", arr)
      else
        s = v.to_s.strip
        if s.start_with?("[") && s.end_with?("]")
          begin
            require "json"
            arr = JSON.parse(s)
            arr = Array(arr).map{|x| x.to_s.strip}.reject{|x| x.empty?}.uniq
            event.set("hashtags", arr)
          rescue
            arr = s.split(",").map{|x| x.strip}.reject{|x| x.empty?}.uniq
            event.set("hashtags", arr)
          end
        else
          arr = s.split(",").map{|x| x.strip}.reject{|x| x.empty?}.uniq
          event.set("hashtags", arr)
        end
      end
    '
  }

  # updated_at → es_version (epoch_millis) for external versioning
  # Logstash::Timestamp#to_f : seconds(float) → millis(int)
  date {
    match  => ["updated_at", "ISO8601", "yyyy-MM-dd HH:mm:ss", "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"]
    target => "updated_at"
  }
  ruby {
    code => '
      ts = event.get("updated_at")
      if ts
        # to_f: seconds; multiply 1000 → epoch_millis
        millis = (ts.to_f * 1000.0).to_i
        event.set("es_version", millis)
      else
        # fallback: still a positive number
        event.set("es_version", (event.get("book_id") || 0).to_i)
      end
    '
  }
}

output {
  if [es_delete_flag] == "Y" {
    # (1) ES delete (with external version)
    elasticsearch {
      hosts         => ["http://localhost:9200"]
      index         => "search-all-books"
      action        => "delete"
      document_id   => "%{book_id}"
      version       => "%{es_version}"
      version_type  => "external"
      # ignore if not found (no retry on conflict for delete)
      retry_on_conflict => 0
    }

    # (2) DB children delete (order matters)
    jdbc {
      driver_jar_path    => "C:/Work/logstashconf/ojdbc11.jar"
      driver_class       => "oracle.jdbc.OracleDriver"
      connection_string  => "jdbc:oracle:thin:@localhost:1521:xe"
      username           => "GEULBUT"
      password           => "1234567890"
      statement => [ "DELETE FROM BOOK_HASHTAGS WHERE BOOK_ID = ?", "book_id" ]
    }
    jdbc {
      driver_jar_path    => "C:/Work/logstashconf/ojdbc11.jar"
      driver_class       => "oracle.jdbc.OracleDriver"
      connection_string  => "jdbc:oracle:thin:@localhost:1521:xe"
      username           => "GEULBUT"
      password           => "1234567890"
      statement => [ "DELETE FROM WISHLISTS WHERE BOOK_ID = ?", "book_id" ]
    }
    jdbc {
      driver_jar_path    => "C:/Work/logstashconf/ojdbc11.jar"
      driver_class       => "oracle.jdbc.OracleDriver"
      connection_string  => "jdbc:oracle:thin:@localhost:1521:xe"
      username           => "GEULBUT"
      password           => "1234567890"
      statement => [ "DELETE FROM CARTS WHERE BOOK_ID = ?", "book_id" ]
    }
    jdbc {
      driver_jar_path    => "C:/Work/logstashconf/ojdbc11.jar"
      driver_class       => "oracle.jdbc.OracleDriver"
      connection_string  => "jdbc:oracle:thin:@localhost:1521:xe"
      username           => "GEULBUT"
      password           => "1234567890"
      statement => [ "DELETE FROM ORDERED_ITEM WHERE BOOK_ID = ?", "book_id" ]
    }

    # (3) DB parent delete
    jdbc {
      driver_jar_path    => "C:/Work/logstashconf/ojdbc11.jar"
      driver_class       => "oracle.jdbc.OracleDriver"
      connection_string  => "jdbc:oracle:thin:@localhost:1521:xe"
      username           => "GEULBUT"
      password           => "1234567890"
      statement => [ "DELETE FROM BOOKS WHERE BOOK_ID = ?", "book_id" ]
    }

  } else {
    # Upsert 경로: index + external version (원하면 action=>"update", doc_as_upsert=>true도 가능)
    elasticsearch {
      hosts         => ["http://localhost:9200"]
      index         => "search-all-books"
      document_id   => "%{book_id}"
      action        => "index"
      version       => "%{es_version}"
      version_type  => "external"
    }
  }

  # Debug
  stdout { codec => rubydebug }
}
